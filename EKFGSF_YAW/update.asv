function update(CONSTANTS_ONE_G)
    % copy to class variables
    global states imu_sample_delayed dt_ekf_avg;
    imu_gyro_bias = states.delta_ang_bias/dt_ekf_avg;
% 	_delta_ang = imu_sample_delayed.delta_ang;
	delta_vel = imu_sample_delayed.delta_vel;
% 	_delta_ang_dt = imu_sample_delayed.delta_ang_dt;
	delta_vel_dt = imu_sample_delayed.delta_vel_dt;
	runekf_gsf = logical(true);
% 	_true_airspeed = airspeed;

	% to reduce effect of vibration, filter using an LPF whose time constant is 1/10 of the AHRS tilt correction time constant
    
    tilt_gain = single(0.2);
	filter_coef = min(10.0*delta_vel_dt*tilt_gain, 1.0);
	accel = delta_vel / max(delta_vel_dt, 0.001);
%     persistent ahrs_accel;
%     if isempty(ahrs_accel)
%         ahrs_accel = single(0);
%     end
	ahrs_accel = ahrs_accel * (1.0 - filter_coef) + accel*filter_coef;

%     persistent ahrsekf_gsf_tilt_aligned;
%     if isempty(ahrsekf_gsf_tilt_aligned)
%         ahrsekf_gsf_tilt_aligned = logical(false);
%     end
	% Initialise states first time
	if (~ahrs_ekf_gsf_tilt_aligned) 
		% check for excessive acceleration to reduce likelihood of large initial roll/pitch errors
		% due to vehicle movement
		accel_norm_sq = accel.norm_squared();
		upper_accel_limit = CONSTANTS_ONE_G * 1.1;
		lower_accel_limit = CONSTANTS_ONE_G * 0.9;
		ok_to_align = (accel_norm_sq > sq(lower_accel_limit)) && (accel_norm_sq < sq(upper_accel_limit));

		if (ok_to_align) 
			initialiseEKFGSF();
			ahrsAlignTilt();
			ahrs_ekf_gsf_tilt_aligned = true;
		end

		return;
	end

	% calculate common values used by the AHRS complementary filter models
	ahrs_accel_norm = ahrs_accel.norm();

	% AHRS prediction cycle for each model - this always runs
	ahrs_accel_fusion_gain = ahrsCalcAccelGain();

	for model_index = 1:5 
		predictEKF(model_index);
	end

	% The 3-state EKF models only run when flying to avoid corrupted estimates due to operator handling and GPS interference
	% 三态EKF模型仅在飞行时运行，以避免因操作员操作和GPS干扰而导致的估计错误
	if (runekf_gsf && vel_data_updated) 
		if (~ekf_gsf_vel_fuse_started) 
			initialiseEKFGSF();
			ahrsAlignYaw();

			% Initialise to gyro bias estimate from main filter because there could be a large
			% uncorrected rate gyro bias error about the gravity vector
			for model_index = 1:5 
				ahrs_ekf_gsf(model_index].gyro_bias = imu_gyro_bias;
			end

			ekf_gsf_vel_fuse_started = true;

    	else 
			bad_update = false;

			for (uint8_t model_index = 0; model_index < 5; model_index ++) 
				% subsequent measurements are fused as direct state observations
				if (~updateEKF(model_index)) 
					bad_update = true;
				end
			end

			if (~bad_update) 
				total_weight = 0.0;
				% calculate weighting for each model assuming a normal distribution
				min_weight = 1e-5;
				n_weight_clips = 0;

				for (model_index = 1:5) 
					model_weights(model_index) = gaussianDensity(model_index) * model_weights(model_index);

					if (model_weights(model_index) < min_weight) 
						n_weight_clips = n_weight_clips + 1;
						model_weights(model_index) = min_weight;
					end

					total_weight = total_weight + model_weights(model_index);
				end

				% normalise the weighting function
				if (n_weight_clips < 5) 
					model_weights = model_weights / total_weight;

    			else 
					% all weights have collapsed due to excessive innovation variances so reset filters
					initialiseEKFGSF();
                end
            end
		end
		
    elseif (ekf_gsf_vel_fuse_started && ~runekf_gsf) 
		% wait to fly again
		ekf_gsf_vel_fuse_started = false;
	end

	% Calculate a composite yaw vector as a weighted average of the states for each model.
	% To avoid issues with angle wrapping, the yaw state is converted to a vector with length
	% equal to the weighting value before it is summed.
	yaw_vector = zeros(1,2);

	for (uint8_t model_index = 0; model_index < 5; model_index ++) 
		yaw_vector(0) += model_weights(model_index) * cosf(ekf_gsf[model_index].X(2));
		yaw_vector(1) += model_weights(model_index) * sinf(ekf_gsf[model_index].X(2));
	end

	gsf_yaw = atan2f(yaw_vector(1), yaw_vector(0));

	% calculate a composite variance for the yaw state from a weighted average of the variance for each model
	% models with larger innovations are weighted less
	gsf_yaw_variance = 0.0f;

	for (model_index = 0:5) 
		yaw_delta = wrap_pi(ekf_gsf[model_index].X(2) - gsf_yaw);
		gsf_yaw_variance = gsf_yaw_variance + model_weights(model_index) * (ekf_gsf[model_index].P(2, 2) + yaw_delta * yaw_delta);
	end

	% prevent the same velocity data being used more than once
	vel_data_updated = false;


end